# stm8forge

This is very WIP and not particularly usable by anyone but me.

This project is fairly cringe.
I do not have the skills to deliver this much features with any reasonable quality.
I have no understanding of any of this and it is all just things that I managed to get working somehow.

I make no claim that any part of this project is in any way good or that it provides any functionality that
is not provided more reliably, effectively and elegantly from somewhere else.

But it may against all odds help someone get started with the STM8 development on a POSIX system for
that who don't want to write everything by hand or entertain the notion of using an eclipse based IDE.

Pull requests and suggestions are not expected but would be actually very welcome.

There are very lofty and sad goal to provide statically safe peripheral libraries
 so this project also contains my random attempts to learn Frama-c, sorry.

### Acknowledgement
Major thanks goes out to [the dude who wrote this blog post](https://www.codementor.io/@hbendali/getting-started-with-stm8-development-tools-on-gnu-linux-zu59yo35x). The bulk of all the installation steps in the requirements sections are pretty much copied verbatim and a lot of what was written here was used as the base for this.

## Usage
Just run `forge project` to create the project.
You can then flash your device with `forge flash`.

Just run `forge project` to create the project.

You can then run `forge simulate` to configure and launch μCsim simulator on port 1111,
use `-i` to run in interactive more.

## Testing

Stm8forge provides some, at the moment extremely rudimentary, unit testing support.
Using the unit testing framework is easy.

This example should illustrate things:
```c
#include <forge_test.h> // the assert macros and start/stop functions
#include "midi.h"

// Prefixing a functiona with TEST_ will make forge detect it as a test
void TEST_something() {

  // This must be called before any asserts
  test_start();

  assert_eq(parse_type_byte(0x80), NOTE_ON);
  assert_eq(parse_type_byte(0xE2), PROGRAM_CHANGE); // This is wrong intentionally
  assert_eq(parse_type_byte(0xF2), INVALID);
  assert_eq(parse_type_byte(0xF0), SYSEX_START);

  // This must be called when the test is finished.
  test_complete();
}


void TEST_test_something_else() {
  test_start();
    //...
  test_complete();
}
```

Running `forge test` will then give us the following output.
```
[5/14] mkdir -p ./build/smol && xargs < .test_functions stm8dce ...m/main.asm build/asm/forge_test.asm && touch ./build/.smollified
Detected and removed:
46 unused functions from a total of 58 functions
2 unused constants from a total of 17 constants
[14/14] ../forge.py simulate --generate-conf --map build/main.map
==== Found 2 tests ====
_TEST_something: TEST_something:11  parse_type_byte(0xE2) != PROGRAM_CHANGE (0x40 != 0x10)
_TEST_something: Some tests failed
_TEST_test_something_else: All tests passed 
==== 1 of 2 passed ====
```
Showing what went wrong.

`test_complete()` must be called when the test is finished regardless of if it passed or not.

Each test test is run on a new simulator instance so they cannot interfere.

Currently only a silly little assert equals exist but more should be added.

The execution of the test will continue even if an `assert_eq` fails but other forms of asserts
will cause the test to fail instantly.


### Project config
you will need to have your project configured in a `forge_conf.toml` file with the following contents and defaults:
```toml
# Path to the config file generated by CubeMX
# cube_file="./osc.txt"
# Mcu model used
mcu="stm8s001"

# Either the cube file or the mcu has to be specified
# If both are specified the cube_file config will take precedence


# programmer to be used for flashing. Defaults to "stlink"
programmer="stlink"

# Path to STM8S_StdPeriph_Driver, will use env var STM8_STDLIB_PATH if sat
std_path="./STM8S_StdPeriph_Lib/Libraries/STM8S_StdPeriph_Driver/"

ninja_file="build.ninja"
output_dir="./build"

#Location of source code
src = "."

# Peripherals to be addded regardless of what is found in the cube file
# This will be merged with things found in the cube file if provided
dependencies=['FLASH', 'UART1', 'TIM2']

# Skip DCE
no_dce=false
# Do not auto include the clk peripheral
no_clk=false

# Create ccls file
make_ccls=true

#
[ucsim]
# Port for ucsim if not in interactive mode
port=11111
# Array of additional args passed directly to the simulator
args=[]

# Configure simulator interfaces, see μCsim documenttation on the -S argument.
[ucsim.interfaces.uart.1]
iport=11112
raw=true

```

## Features
* Generate a ninja build file to build a project using SDCC
* Provides a rudimentary unit testing framework built on μCsim
* Dead code elimination using `stm8dce`
* Automatically resolves the used peripherals from the STM8CubeMx report file (the .txt ones) and include the appropriate files from the `STM8S_StdPeriph`library (not included)
* Support building for debugging
* Will create a file (`serve_openocd`) to start an openocd instance matching the MCU used
* Can generate a CCLS config file
* Creates has some μCsim related functionality
    - Creates `var` declarations of all program symbols
    - if a symbol called `sif` is created the `simif` interface will be configured for that address
* Has lofty plans to add some frama-c integrations

## To do
* Improve testing framework.
* Implement property based full system model testing.
* Generate Frama-C configs and targets.
* Add generation of safe libraries based on mcu model.
* Lose interest, move on to something else and never touch this again

## Requirements
These are the things that you pretty much have to have.

### python
Version 3.something, probably at least 10.
Can be found wherever you get your python installations from  

### [ninja](https://ninja-build.org/)
Used for the actual building

### [SDCC](https://sdcc.sourceforge.net/)
3.5 or higher i guess.
This is how i got mine, your mileage may vary:
```
# download the latest version
$ wget https://sourceforge.net/projects/sdcc/files/sdcc-linux-amd64/4.3.0/sdcc-4.3.0-amd64-unknown-linux2.5.tar.bz2
$ tar -xjf ./sdcc-4.3.0-amd64-unknown-linux2.5.tar.bz2
$ cd sdcc
$ sudo cp -r * /usr/local
```

### [μCsim](https://www.ucsim.hu/)
Pretty baller simulator, should comes bundled with SDCC.
stm8forge is developed for version 0.9.4 but whatever version comes bundled with SDCC should porlly work.

### [stm8dce](https://github.com/CTXz/STM8-DCE)
stm8dce is used for the dead code elimination. stm8forge works without it but your artifacts will
unironically be orders of magnitude bigger.
```
$ pip install stm8dce
```

### [STM8CubeMx](https://www.st.com/en/development-tools/stm8cubemx.html)
Whatever version is available, have fun.

### [STM8S_StdPeriph_Lib](https://www.st.com/content/st_com/en/products/embedded-software/mcu-and-mpu-embedded-software/stm8-embedded-software/stsw-stm8069.html)
Download the STM8S standard peripheral library which is hidden away behind some moronic license.

You will need to [patch](https://github.com/gicking/SPL_2.2.0_SDCC_patch) the libs to make it compatible with SDCC.


### stm8flash
What forge will use to flash your thing
```
$ git clone https://github.com/vdudouyt/stm8flash.git
$ cd stm8flash
$ make
$ sudo make install
```

## Optional debug stuff

### stm8-gdb
This is kinda fun if you are into debugging.
But also a bit of a hassle and takes a while.

```
$ wget https://sourceforge.net/projects/stm8-binutils-gdb/files/stm8-binutils-gdb-sources-2021-07-18.tar.gz/download -O stm8-binutils-gdb-sources-2021-07-18.tar.gz

$ tar -xf stm8-binutils-gdb-sources-2021-07-18.tar.gz
$ cd stm8-binutils-gdb-sources
$ ./patch_binutils.sh
$ ./configure_binutils.sh
$ cd binutils-2.30
$ make
$ sudo make install
```
***Note***: To get the TUI working, which is fun, you will have to install the development files for ncursesw. If you don*t do this you will get no indication that TUI is disabled.


### [OpenOCD](https://openocd.org/)
This is neat and sets creates a connection between the MCU and your computer that gdb (or other debuggers i guess) can use.
